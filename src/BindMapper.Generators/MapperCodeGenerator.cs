using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace BindMapper.Generators;

/// <summary>
/// Generates the public Mapper API methods for object-to-object mapping.
/// Produces optimized code with aggressive inlining and cache locality improvements.
/// </summary>
internal sealed class MapperCodeGenerator
{
    private readonly StringBuilder _sb = new(capacity: 8192);
    
    /// <summary>
    /// Cache for PropertyMappingPlan analysis to avoid redundant symbol walking.
    /// Key format: "SourceFQN|DestFQN"
    /// </summary>
    private readonly Dictionary<string, PropertyMappingPlan> _mappingPlanCache = new(StringComparer.Ordinal);
    
    /// <summary>
    /// Cache for public properties to avoid repeated symbol analysis.
    /// Key: SymbolEqualityComparer.Default for ITypeSymbol
    /// </summary>
    private readonly Dictionary<ITypeSymbol, IReadOnlyList<PropertyInfo>> _propertyCache = 
        new(SymbolEqualityComparer.Default);

    /// <summary>
    /// Generates the complete Mapper.g.cs source file.
    /// </summary>
    public string GenerateMapperSource(IReadOnlyList<MappingConfiguration> mappings)
    {
        if (mappings.Count == 0)
            return string.Empty;

        _sb.Clear();
        _sb.AppendLine("// <auto-generated />");
        _sb.AppendLine("#nullable enable");
        _sb.AppendLine("using System;");
        _sb.AppendLine("using System.Collections.Generic;");
        _sb.AppendLine("using System.Runtime.CompilerServices;");
        _sb.AppendLine("using System.Runtime.InteropServices;");
        _sb.AppendLine();
        _sb.AppendLine("namespace BindMapper;");
        _sb.AppendLine();
        _sb.AppendLine("/// <summary>Auto-generated mapping methods.</summary>");
        _sb.AppendLine("public static partial class Mapper");
        _sb.AppendLine("{");

        foreach (var mapping in mappings)
        {
            AppendMapNewInstance(mapping, mappings);
            AppendMapGenericNew(mapping);
            AppendMapToExisting(mapping, mappings);
        }

        AppendCollectionMappers(mappings);

        _sb.AppendLine("}");
        return _sb.ToString();
    }

    private void AppendMapNewInstance(
        MappingConfiguration config,
        IReadOnlyList<MappingConfiguration> mappings)
    {
        var destProperties = GetOrCacheProperties(config.DestinationTypeSymbol);
        var sourceProperties = GetOrCacheProperties(config.SourceTypeSymbol);

        // Analyze all mappings in one pass
        var plan = GetOrAnalyzeMappingPlan(config,
            destProperties.Where(p => p.IsWriteable && !p.IsIgnored).ToList(),
            sourceProperties,
            mappings);

        _sb.AppendLine();
        _sb.AppendLine("    /// <summary>");
        _sb.AppendLine($"    /// Maps {config.SourceTypeName} to a new {config.DestinationTypeName}.");
        _sb.AppendLine("    /// JIT-optimized object initializer pattern with aggressive inlining.");
        _sb.AppendLine("    /// </summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static {config.DestinationType} To({config.SourceType} source)");
        _sb.AppendLine("    {");
        _sb.AppendLine($"        ArgumentNullException.ThrowIfNull(source);");
        _sb.AppendLine($"        return new {config.DestinationType}");
        _sb.AppendLine("        {");

        var assignments = new List<string>(capacity: destProperties.Count);

        foreach (var (prop, info, resType) in plan.GetAllAssignmentsOrdered())
        {
            var assignment = GeneratePropertyAssignmentFromInfo(prop, info, config.SourceType);
            if (assignment != null)
                assignments.Add(assignment);
        }

        _sb.AppendLine(string.Join(",\n", assignments));
        _sb.AppendLine("        };");
        _sb.AppendLine("    }");
    }

    /// <summary>
    /// Generates a property assignment statement from cached mapping information.
    /// Avoids dictionary lookups by using pre-resolved PropertyMappingInfo.
    /// </summary>
    private static string? GeneratePropertyAssignmentFromInfo(
        PropertyInfo destProp,
        PropertyMappingInfo info,
        string sourceTypeName)
    {
        return info.ResolutionType switch
        {
            MappingResolutionType.Constant =>
                $"            {destProp.Name} = {info.ConstantValue}",

            MappingResolutionType.Expression =>
                $"            {destProp.Name} = {ExpressionNormalizer.NormalizeExpression(info.CustomExpression ?? "")}",

            MappingResolutionType.Direct when info.SourceProperty != null =>
                $"            {destProp.Name} = source.{info.SourceProperty.Name}",

            MappingResolutionType.Nested when info.SourceProperty != null && info.NestedMapping != null =>
                info.SourceProperty.Type.IsReferenceType
                    ? $"            {destProp.Name} = source.{info.SourceProperty.Name} is {{ }} __src ? To(__src) : null"
                    : $"            {destProp.Name} = To(source.{info.SourceProperty.Name})",

            _ => null,
        };
    }

    private void AppendMapGenericNew(MappingConfiguration config)
    {
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>");
        _sb.AppendLine($"    /// Maps {config.SourceTypeName} to a new instance of {config.DestinationTypeName} (generic overload).");
        _sb.AppendLine($"    /// </summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static TDestination To<TDestination>({config.SourceType} source) where TDestination : {config.DestinationType}");
        _sb.AppendLine("    {");
        _sb.AppendLine($"        var __result = To(source);");
        _sb.AppendLine($"        // Safe cast: constraint ensures TDestination is assignable from {config.DestinationTypeName}");
        _sb.AppendLine($"        return (TDestination)(object)__result!;");
        _sb.AppendLine("    }");
    }

    private void AppendMapToExisting(
        MappingConfiguration config,
        IReadOnlyList<MappingConfiguration> mappings)
    {
        var destProperties = GetOrCacheProperties(config.DestinationTypeSymbol);
        var sourceProperties = GetOrCacheProperties(config.SourceTypeSymbol);

        // Analyze all mappings in one pass
        var plan = GetOrAnalyzeMappingPlan(config, destProperties, sourceProperties, mappings);

        _sb.AppendLine();
        _sb.AppendLine("    /// <summary>");
        _sb.AppendLine($"    /// Maps {config.SourceTypeName} to existing {config.DestinationTypeName} (zero allocation).");
        _sb.AppendLine("    /// </summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static void To({config.SourceType} source, {config.DestinationType} destination)");
        _sb.AppendLine("    {");
        _sb.AppendLine("        ArgumentNullException.ThrowIfNull(source);");
        _sb.AppendLine("        ArgumentNullException.ThrowIfNull(destination);");
        _sb.AppendLine();

        // Generate assignments in optimal order
        foreach (var (prop, info, resType) in plan.GetAllAssignmentsOrdered())
        {
            GeneratePropertyAssignmentToExisting(prop, info, config.SourceType);
        }

        _sb.AppendLine("    }");
    }

    private void GeneratePropertyAssignmentToExisting(
        PropertyInfo destProp,
        PropertyMappingInfo info,
        string sourceTypeName)
    {
        switch (info.ResolutionType)
        {
            case MappingResolutionType.Direct when !info.SourceProperty?.Type.IsReferenceType == true:
                // Value-type direct assignment (branchless)
                _sb.AppendLine($"        destination.{destProp.Name} = source.{info.SourceProperty!.Name};");
                break;

            case MappingResolutionType.Direct when info.SourceProperty?.Type.IsReferenceType == true:
                // Reference-type direct assignment
                _sb.AppendLine($"        destination.{destProp.Name} = source.{info.SourceProperty!.Name};");
                break;

            case MappingResolutionType.Constant:
                _sb.AppendLine($"        destination.{destProp.Name} = {info.ConstantValue};");
                break;

            case MappingResolutionType.Expression:
                _sb.AppendLine($"        destination.{destProp.Name} = {ExpressionNormalizer.NormalizeExpression(info.CustomExpression ?? "")};");
                break;

            case MappingResolutionType.Nested when info.SourceProperty?.Type.IsReferenceType == true && info.NestedMapping != null:
                _sb.AppendLine($"        if (source.{info.SourceProperty!.Name} is {{ }} _src{destProp.Name})");
                _sb.AppendLine("        {");
                _sb.AppendLine($"            if (destination.{destProp.Name} is {{ }} _dst{destProp.Name}) To(_src{destProp.Name}, _dst{destProp.Name});");
                _sb.AppendLine($"            else destination.{destProp.Name} = To(_src{destProp.Name});");
                _sb.AppendLine("        }");
                _sb.AppendLine($"        else destination.{destProp.Name} = null;");
                break;

            case MappingResolutionType.Nested when info.SourceProperty?.Type.IsReferenceType == false && info.NestedMapping != null:
                _sb.AppendLine($"        destination.{destProp.Name} = To(source.{info.SourceProperty!.Name});");
                break;
        }
    }

    private void AppendCollectionMappers(IReadOnlyList<MappingConfiguration> mappings)
    {
        foreach (var mapping in mappings)
        {
            // Only generate collection mappers if boxing pattern is safe
            if (TypeCompatibilityValidator.CanUseBoxingPattern(mapping))
            {
                AppendToListMethod(mapping);
                AppendToArrayMethod(mapping);
                AppendToEnumerableMethod(mapping);
                AppendToSpanMethod(mapping);
            }
            else
            {
                // For unsafe combinations, generate safe constraint-based versions only
                AppendSafeCollectionMappers(mapping);
            }
        }
    }

    /// <summary>
    /// Generates safe collection mappers for value types without unsafe boxing pattern.
    /// Uses factory pattern via Func delegate for type-safe collection mapping.
    /// CRITICAL FIX: Ensures value type collections don't fail at runtime.
    /// </summary>
    private void AppendSafeCollectionMappers(MappingConfiguration mapping)
    {
        // For value type combinations, emit methods that work with delegates
        // User will need to provide a mapping function
        
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>Safe collection mapper for {mapping.SourceTypeName} to {mapping.DestinationTypeName} (value types).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static List<{mapping.DestinationType}> MapList(");
        _sb.AppendLine($"        List<{mapping.SourceType}>? source,");
        _sb.AppendLine($"        Func<{mapping.SourceType}, {mapping.DestinationType}> mapper)");
        _sb.AppendLine("    {");
        _sb.AppendLine("        if (source is null || source.Count == 0)");
        _sb.AppendLine("            return new List<" + mapping.DestinationType + ">();");
        _sb.AppendLine();
        _sb.AppendLine("        var result = new List<" + mapping.DestinationType + ">(source.Count);");
        _sb.AppendLine("#if NET8_0_OR_GREATER");
        _sb.AppendLine("        var sourceSpan = CollectionsMarshal.AsSpan(source);");
        _sb.AppendLine("        CollectionsMarshal.SetCount(result, source.Count);");
        _sb.AppendLine("        var destSpan = CollectionsMarshal.AsSpan(result);");
        _sb.AppendLine("        for (int i = 0; i < sourceSpan.Length; i++)");
        _sb.AppendLine("            destSpan[i] = mapper(sourceSpan[i]);");
        _sb.AppendLine("#else");
        _sb.AppendLine("        foreach (var item in source)");
        _sb.AppendLine("            result.Add(mapper(item));");
        _sb.AppendLine("#endif");
        _sb.AppendLine("        return result;");
        _sb.AppendLine("    }");
        _sb.AppendLine();
        
        _sb.AppendLine($"    /// <summary>Safe collection mapper for {mapping.SourceTypeName} to {mapping.DestinationTypeName} array (value types).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static {mapping.DestinationType}[] MapArray(");
        _sb.AppendLine($"        {mapping.SourceType}[]? source,");
        _sb.AppendLine($"        Func<{mapping.SourceType}, {mapping.DestinationType}> mapper)");
        _sb.AppendLine("    {");
        _sb.AppendLine("        if (source is null || source.Length == 0)");
        _sb.AppendLine("            return Array.Empty<" + mapping.DestinationType + ">();");
        _sb.AppendLine();
        _sb.AppendLine("        var result = new " + mapping.DestinationType + "[source.Length];");
        _sb.AppendLine("        for (int i = 0; i < source.Length; i++)");
        _sb.AppendLine("            result[i] = mapper(source[i]);");
        _sb.AppendLine("        return result;");
        _sb.AppendLine("    }");
    }

    private void AppendToSpanMethod(MappingConfiguration mapping)
    {
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>Maps ReadOnlySpan of {mapping.SourceTypeName} to Span of {mapping.DestinationTypeName} (true zero-allocation).</summary>");
        _sb.AppendLine("    /// <remarks>");
        _sb.AppendLine("    /// ⚠️ WARNING: Destination span must have EXACTLY source.Length capacity!");
        _sb.AppendLine("    /// Stack-allocated spans (stackalloc T[100]) may overflow if used with large source spans.");
        _sb.AppendLine("    /// For untrusted input sizes, use ToList() or ToArray() instead.");
        _sb.AppendLine("    /// </remarks>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static void ToSpan(ReadOnlySpan<{mapping.SourceType}> source, Span<{mapping.DestinationType}> destination)");
        _sb.AppendLine("    {");
        _sb.AppendLine("        if (source.Length > destination.Length)");
        _sb.AppendLine("            throw new ArgumentException(\"Destination span must be at least as long as source span.\", nameof(destination));");
        _sb.AppendLine();
        _sb.AppendLine("        for (int i = 0; i < source.Length; i++)");
        _sb.AppendLine("            destination[i] = To(source[i]);");
        _sb.AppendLine("    }");
    }

    private void AppendToListMethod(MappingConfiguration mapping)
    {
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>Maps IEnumerable of {mapping.SourceTypeName} to List of {mapping.DestinationTypeName}.</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static List<TDestination> ToList<TDestination>(IEnumerable<{mapping.SourceType}>? source) where TDestination : {mapping.DestinationType}");
        _sb.AppendLine("    {");
        _sb.AppendLine("        if (source is null) return new List<TDestination>();");
        _sb.AppendLine();

        // Fast path for List<T>
        _sb.AppendLine($"        if (source is List<{mapping.SourceType}> sourceList)");
        _sb.AppendLine("        {");
        _sb.AppendLine("            if (sourceList.Count == 0) return new List<TDestination>();");
        _sb.AppendLine("            var count = sourceList.Count;");
        _sb.AppendLine("            var result = new List<TDestination>(count);");
        _sb.AppendLine("#if NET8_0_OR_GREATER");
        _sb.AppendLine("            var sourceSpan = CollectionsMarshal.AsSpan(sourceList);");
        _sb.AppendLine("            CollectionsMarshal.SetCount(result, count);");
        _sb.AppendLine("            var destSpan = CollectionsMarshal.AsSpan(result);");
        _sb.AppendLine("            for (int i = 0; i < sourceSpan.Length; i++)");
        _sb.AppendLine("            {");
        _sb.AppendLine($"                var mapped = To(sourceSpan[i]);");
        _sb.AppendLine($"                destSpan[i] = (TDestination)(object)mapped!;");
        _sb.AppendLine("            }");
        _sb.AppendLine("#else");
        _sb.AppendLine("            foreach (var item in sourceList)");
        _sb.AppendLine($"                result.Add((TDestination)(object)To(item)!);");
        _sb.AppendLine("#endif");
        _sb.AppendLine("            return result;");
        _sb.AppendLine("        }");
        _sb.AppendLine();

        // Fast path for arrays
        _sb.AppendLine($"        if (source is {mapping.SourceType}[] sourceArray)");
        _sb.AppendLine("        {");
        _sb.AppendLine("            if (sourceArray.Length == 0) return new List<TDestination>();");
        _sb.AppendLine("            var result = new List<TDestination>(sourceArray.Length);");
        _sb.AppendLine("            foreach (var item in sourceArray)");
        _sb.AppendLine($"                result.Add((TDestination)(object)To(item)!);");
        _sb.AppendLine("            return result;");
        _sb.AppendLine("        }");
        _sb.AppendLine();

        // Slow path with TryGetNonEnumeratedCount
        _sb.AppendLine("#if NET6_0_OR_GREATER");
        _sb.AppendLine("        if (System.Linq.Enumerable.TryGetNonEnumeratedCount(source, out var estimatedCount))");
        _sb.AppendLine("        {");
        _sb.AppendLine("            var result = new List<TDestination>(estimatedCount);");
        _sb.AppendLine("            foreach (var item in source)");
        _sb.AppendLine($"                result.Add((TDestination)(object)To(item)!);");
        _sb.AppendLine("            return result;");
        _sb.AppendLine("        }");
        _sb.AppendLine("#endif");
        _sb.AppendLine();

        _sb.AppendLine("        var list = new List<TDestination>();");
        _sb.AppendLine("        foreach (var item in source)");
        _sb.AppendLine($"            list.Add((TDestination)(object)To(item)!);");
        _sb.AppendLine("        return list;");
        _sb.AppendLine("    }");
    }

    private void AppendToArrayMethod(MappingConfiguration mapping)
    {
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>Maps IEnumerable of {mapping.SourceTypeName} to array of {mapping.DestinationTypeName}.</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static TDestination[] ToArray<TDestination>(IEnumerable<{mapping.SourceType}>? source) where TDestination : {mapping.DestinationType}");
        _sb.AppendLine("    {");
        _sb.AppendLine("        if (source is null) return Array.Empty<TDestination>();");
        _sb.AppendLine();

        // Fast path for arrays
        _sb.AppendLine($"        if (source is {mapping.SourceType}[] sourceArray)");
        _sb.AppendLine("        {");
        _sb.AppendLine("            if (sourceArray.Length == 0) return Array.Empty<TDestination>();");
        _sb.AppendLine("            var result = new TDestination[sourceArray.Length];");
        _sb.AppendLine("            for (int i = 0; i < sourceArray.Length; i++)");
        _sb.AppendLine($"                result[i] = (TDestination)(object)To(sourceArray[i])!;");
        _sb.AppendLine("            return result;");
        _sb.AppendLine("        }");
        _sb.AppendLine();

        // Fallback to list then array
        _sb.AppendLine("        return ToList<TDestination>(source).ToArray();");
        _sb.AppendLine("    }");
    }

    private void AppendToEnumerableMethod(MappingConfiguration mapping)
    {
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>Maps IEnumerable of {mapping.SourceTypeName} to IEnumerable of {mapping.DestinationTypeName} (lazy evaluation).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"    public static IEnumerable<TDestination> ToEnumerable<TDestination>(IEnumerable<{mapping.SourceType}>? source) where TDestination : {mapping.DestinationType}");
        _sb.AppendLine("    {");
        _sb.AppendLine("        if (source is null) yield break;");
        _sb.AppendLine("        foreach (var item in source)");
        _sb.AppendLine($"            yield return (TDestination)(object)To(item)!;");
        _sb.AppendLine("    }");
    }

    /// <summary>
    /// Gets or analyzes a mapping plan, using cache to avoid redundant symbol walking.
    /// </summary>
    private PropertyMappingPlan GetOrAnalyzeMappingPlan(
        MappingConfiguration config,
        IReadOnlyList<PropertyInfo> destProperties,
        IReadOnlyList<PropertyInfo> sourceProperties,
        IReadOnlyList<MappingConfiguration> allMappings)
    {
        var cacheKey = $"{config.SourceTypeFullName}|{config.DestinationTypeFullName}";
        
        if (!_mappingPlanCache.TryGetValue(cacheKey, out var plan))
        {
            var analyzer = new PropertyMappingAnalyzer(allMappings);
            plan = analyzer.AnalyzeMappings(config, destProperties, sourceProperties);
            _mappingPlanCache[cacheKey] = plan;
        }
        
        return plan;
    }

    /// <summary>
    /// Gets or caches public properties for a type symbol.
    /// </summary>
    private IReadOnlyList<PropertyInfo> GetOrCacheProperties(ITypeSymbol typeSymbol)
    {
        if (!_propertyCache.TryGetValue(typeSymbol, out var properties))
        {
            properties = SymbolAnalysisHelper.GetPublicProperties(typeSymbol);
            _propertyCache[typeSymbol] = properties;
        }
        
        return properties;
    }
}
