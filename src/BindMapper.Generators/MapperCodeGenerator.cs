using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace BindMapper.Generators;

/// <summary>
/// Generates the public Mapper API methods for object-to-object mapping.
/// Produces optimized code with aggressive inlining and cache locality improvements.
/// </summary>
internal sealed class MapperCodeGenerator
{
    private readonly StringBuilder _sb = new(capacity: 8192);
    
    /// <summary>
    /// Cache for PropertyMappingPlan analysis to avoid redundant symbol walking.
    /// Key format: "SourceFQN|DestFQN"
    /// </summary>
    private readonly Dictionary<string, PropertyMappingPlan> _mappingPlanCache = new(StringComparer.Ordinal);
    
    /// <summary>
    /// Cache for public properties to avoid repeated symbol analysis.
    /// Key: SymbolEqualityComparer.Default for ITypeSymbol
    /// </summary>
    private readonly Dictionary<ITypeSymbol, IReadOnlyList<PropertyInfo>> _propertyCache = 
        new(SymbolEqualityComparer.Default);

    /// <summary>
    /// Generates the complete Mapper.g.cs source file.
    /// OPTIMIZED: Pre-calculates StringBuilder capacity based on mapping count.
    /// </summary>
    public string GenerateMapperSource(IReadOnlyList<MappingConfiguration> mappings)
    {
        if (mappings.Count == 0)
            return string.Empty;

        // OPTIMIZATION: Estimate StringBuilder capacity to avoid reallocations
        // Heuristic: ~2KB header + ~1.5KB per mapping + ~1.5KB per collection method
        int estimatedSize = 2048 +                      // File header and namespace
                           (mappings.Count * 1536) +    // ~1.5KB per mapping (To + ToExisting + generic)
                           (mappings.Count * 1536);     // ~1.5KB per collection methods (5 methods)
        
        _sb.Clear();
        _sb.EnsureCapacity(estimatedSize);

        _sb.AppendLine("// <auto-generated />");
        _sb.AppendLine("#nullable enable");
        _sb.AppendLine("using System;");
        _sb.AppendLine("using System.Collections.Generic;");
        _sb.AppendLine("using System.Collections.ObjectModel;");
        _sb.AppendLine("using System.Runtime.CompilerServices;");
        _sb.AppendLine("using System.Runtime.InteropServices;");
        _sb.AppendLine();
        _sb.AppendLine("namespace BindMapper;");
        _sb.AppendLine();
        _sb.AppendLine("/// <summary>Auto-generated mapping methods.</summary>");
        _sb.AppendLine("public static partial class Mapper");
        _sb.AppendLine("{");

        foreach (var mapping in mappings)
        {
            AppendMapNewInstance(mapping, mappings);
            AppendMapGenericNew(mapping);
            AppendMapToExisting(mapping, mappings);
        }

        AppendCollectionMappers(mappings);

        _sb.AppendLine("}");
        return _sb.ToString();
    }

    private void AppendMapNewInstance(
        MappingConfiguration config,
        IReadOnlyList<MappingConfiguration> mappings)
    {
        var destProperties = GetOrCacheProperties(config.DestinationTypeSymbol);
        var sourceProperties = GetOrCacheProperties(config.SourceTypeSymbol);

        // OPTIMIZED: Filter properties manually to avoid LINQ allocation overhead
        var writeableDestProps = new List<PropertyInfo>(destProperties.Count);
        for (int i = 0; i < destProperties.Count; i++)
        {
            var prop = destProperties[i];
            if (prop.IsWriteable && !prop.IsIgnored)
                writeableDestProps.Add(prop);
        }

        // Analyze all mappings in one pass
        var plan = GetOrAnalyzeMappingPlan(config,
            writeableDestProps,
            sourceProperties,
            mappings);

        _sb.AppendLine();
        _sb.AppendLine("    /// <summary>");
        _sb.AppendLine($"    /// Maps {config.SourceTypeName} to a new {config.DestinationTypeName}.");
        _sb.AppendLine("    /// JIT-optimized object initializer pattern with aggressive inlining.");
        _sb.AppendLine("    /// </summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static {config.DestinationType} To({config.SourceType} source)");
        _sb.AppendLine("    {");
        _sb.AppendLine($"        ArgumentNullException.ThrowIfNull(source);");
        
        // Check if destination is a value type - use Unsafe.SkipInit for perf
        if (!config.DestinationTypeSymbol.IsReferenceType)
        {
            _sb.AppendLine($"        System.Runtime.CompilerServices.Unsafe.SkipInit(out {config.DestinationType} result);");
            _sb.AppendLine();
            
            // For value types, assign fields directly
            foreach (var (prop, info, resType) in plan.GetAllAssignmentsOrdered())
            {
                var assignment = GeneratePropertyAssignmentForValueType(prop, info, config.SourceType);
                if (assignment != null)
                    _sb.AppendLine($"        {assignment}");
            }
            
            _sb.AppendLine("        return result;");
        }
        else
        {
            // For reference types, use object initializer
            _sb.AppendLine($"        return new {config.DestinationType}");
            _sb.AppendLine("        {");

            var assignments = new List<string>(capacity: destProperties.Count);

            foreach (var (prop, info, resType) in plan.GetAllAssignmentsOrdered())
            {
                var assignment = GeneratePropertyAssignmentFromInfo(prop, info, config.SourceType);
                if (assignment != null)
                    assignments.Add(assignment);
            }

            _sb.AppendLine(string.Join(",\n", assignments));
            _sb.AppendLine("        };");
        }
        _sb.AppendLine("    }");
    }

    /// <summary>
    /// Generates a property assignment statement from cached mapping information.
    /// Avoids dictionary lookups by using pre-resolved PropertyMappingInfo.
    /// </summary>
    private static string? GeneratePropertyAssignmentFromInfo(
        PropertyInfo destProp,
        PropertyMappingInfo info,
        string sourceTypeName)
    {
        return info.ResolutionType switch
        {
            MappingResolutionType.Constant =>
                $"            {destProp.Name} = {info.ConstantValue}",

            MappingResolutionType.Expression =>
                $"            {destProp.Name} = {ExpressionNormalizer.NormalizeExpression(info.CustomExpression ?? "")}",

            MappingResolutionType.Direct when info.SourceProperty != null =>
                $"            {destProp.Name} = source.{info.SourceProperty.Name}",

            MappingResolutionType.Nested when info.SourceProperty != null && info.NestedMapping != null =>
                // Optimized nested mapping with efficient null check
                info.SourceProperty.Type.IsReferenceType
                    ? $"            {destProp.Name} = source.{info.SourceProperty.Name} != null ? To(source.{info.SourceProperty.Name}) : null"
                    : $"            {destProp.Name} = To(source.{info.SourceProperty.Name})",

            _ => null,
        };
    }

    /// <summary>
    /// Generates property assignment for value types using direct field assignment.
    /// Used with Unsafe.SkipInit to avoid zero-initialization overhead.
    /// </summary>
    private string? GeneratePropertyAssignmentForValueType(
        PropertyInfo destProp,
        PropertyMappingInfo info,
        string sourceTypeName)
    {
        return info.ResolutionType switch
        {
            MappingResolutionType.Constant =>
                $"result.{destProp.Name} = {info.ConstantValue};",

            MappingResolutionType.Expression =>
                $"result.{destProp.Name} = {ExpressionNormalizer.NormalizeExpression(info.CustomExpression ?? "")};",

            MappingResolutionType.Direct when info.SourceProperty != null =>
                $"result.{destProp.Name} = source.{info.SourceProperty.Name};",

            MappingResolutionType.Nested when info.SourceProperty != null && info.NestedMapping != null =>
                info.SourceProperty.Type.IsReferenceType
                    ? $"result.{destProp.Name} = source.{info.SourceProperty.Name} != null ? To(source.{info.SourceProperty.Name}) : null;"
                    : $"result.{destProp.Name} = To(source.{info.SourceProperty.Name});",

            _ => null,
        };
    }

    private void AppendMapGenericNew(MappingConfiguration config)
    {
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>");
        _sb.AppendLine($"    /// Maps {config.SourceTypeName} to a new instance of {config.DestinationTypeName} (generic overload).");
        _sb.AppendLine($"    /// </summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static TDestination To<TDestination>({config.SourceType} source) where TDestination : {config.DestinationType}");
        _sb.AppendLine("    {");
        _sb.AppendLine($"        var __result = To(source);");
        _sb.AppendLine($"        // Safe cast: constraint ensures TDestination is assignable from {config.DestinationTypeName}");
        _sb.AppendLine($"        return (TDestination)(object)__result!;");
        _sb.AppendLine("    }");
    }

    private void AppendMapToExisting(
        MappingConfiguration config,
        IReadOnlyList<MappingConfiguration> mappings)
    {
        var destProperties = GetOrCacheProperties(config.DestinationTypeSymbol);
        var sourceProperties = GetOrCacheProperties(config.SourceTypeSymbol);

        // Analyze all mappings in one pass
        var plan = GetOrAnalyzeMappingPlan(config, destProperties, sourceProperties, mappings);

        _sb.AppendLine();
        _sb.AppendLine("    /// <summary>");
        _sb.AppendLine($"    /// Maps {config.SourceTypeName} to existing {config.DestinationTypeName} (zero allocation).");
        _sb.AppendLine("    /// </summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static void To({config.SourceType} source, {config.DestinationType} destination)");
        _sb.AppendLine("    {");
        _sb.AppendLine("        ArgumentNullException.ThrowIfNull(source);");
        _sb.AppendLine("        ArgumentNullException.ThrowIfNull(destination);");
        _sb.AppendLine();

        // Generate assignments in optimal order
        foreach (var (prop, info, resType) in plan.GetAllAssignmentsOrdered())
        {
            GeneratePropertyAssignmentToExisting(prop, info, config.SourceType);
        }

        _sb.AppendLine("    }");
    }

    private void GeneratePropertyAssignmentToExisting(
        PropertyInfo destProp,
        PropertyMappingInfo info,
        string sourceTypeName)
    {
        switch (info.ResolutionType)
        {
            case MappingResolutionType.Direct when !info.SourceProperty?.Type.IsReferenceType == true:
                // Value-type direct assignment (branchless)
                _sb.AppendLine($"        destination.{destProp.Name} = source.{info.SourceProperty!.Name};");
                break;

            case MappingResolutionType.Direct when info.SourceProperty?.Type.IsReferenceType == true:
                // Reference-type direct assignment
                _sb.AppendLine($"        destination.{destProp.Name} = source.{info.SourceProperty!.Name};");
                break;

            case MappingResolutionType.Constant:
                _sb.AppendLine($"        destination.{destProp.Name} = {info.ConstantValue};");
                break;

            case MappingResolutionType.Expression:
                _sb.AppendLine($"        destination.{destProp.Name} = {ExpressionNormalizer.NormalizeExpression(info.CustomExpression ?? "")};");
                break;

            case MappingResolutionType.Nested when info.SourceProperty?.Type.IsReferenceType == true && info.NestedMapping != null:
                _sb.AppendLine($"        if (source.{info.SourceProperty!.Name} is {{ }} _src{destProp.Name})");
                _sb.AppendLine("        {");
                _sb.AppendLine($"            if (destination.{destProp.Name} is {{ }} _dst{destProp.Name}) To(_src{destProp.Name}, _dst{destProp.Name});");
                _sb.AppendLine($"            else destination.{destProp.Name} = To(_src{destProp.Name});");
                _sb.AppendLine("        }");
                _sb.AppendLine($"        else destination.{destProp.Name} = null;");
                break;

            case MappingResolutionType.Nested when info.SourceProperty?.Type.IsReferenceType == false && info.NestedMapping != null:
                _sb.AppendLine($"        destination.{destProp.Name} = To(source.{info.SourceProperty!.Name});");
                break;
        }
    }

    private void AppendCollectionMappers(IReadOnlyList<MappingConfiguration> mappings)
    {
        foreach (var mapping in mappings)
        {
            // Only generate collection mappers if boxing pattern is safe
            if (TypeCompatibilityValidator.CanUseBoxingPattern(mapping))
            {
                AppendToListMethod(mapping);
                AppendToArrayMethod(mapping);
                AppendToEnumerableMethod(mapping);
                AppendToCollectionMethod(mapping);
                AppendToSpanMethod(mapping);
            }
            else
            {
                // For unsafe combinations, generate safe constraint-based versions only
                AppendSafeCollectionMappers(mapping);
            }
        }
    }

    /// <summary>
    /// Generates safe collection mappers for value types without unsafe boxing pattern.
    /// Uses factory pattern via Func delegate for type-safe collection mapping.
    /// CRITICAL FIX: Ensures value type collections don't fail at runtime.
    /// </summary>
    private void AppendSafeCollectionMappers(MappingConfiguration mapping)
    {
        // For value type combinations, emit methods that work with delegates
        // User will need to provide a mapping function
        
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>Safe collection mapper for {mapping.SourceTypeName} to {mapping.DestinationTypeName} (value types).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static List<{mapping.DestinationType}> MapList(");
        _sb.AppendLine($"        List<{mapping.SourceType}>? source,");
        _sb.AppendLine($"        Func<{mapping.SourceType}, {mapping.DestinationType}> mapper)");
        _sb.AppendLine("    {");
        _sb.AppendLine("        if (source is null || source.Count == 0)");
        _sb.AppendLine("            return new List<" + mapping.DestinationType + ">();");
        _sb.AppendLine();
        _sb.AppendLine("        var result = new List<" + mapping.DestinationType + ">(source.Count);");
        _sb.AppendLine("#if NET8_0_OR_GREATER");
        _sb.AppendLine("        var sourceSpan = CollectionsMarshal.AsSpan(source);");
        _sb.AppendLine("        CollectionsMarshal.SetCount(result, source.Count);");
        _sb.AppendLine("        var destSpan = CollectionsMarshal.AsSpan(result);");
        _sb.AppendLine("        for (int i = 0; i < sourceSpan.Length; i++)");
        _sb.AppendLine("            destSpan[i] = mapper(sourceSpan[i]);");
        _sb.AppendLine("#else");
        _sb.AppendLine("        foreach (var item in source)");
        _sb.AppendLine("            result.Add(mapper(item));");
        _sb.AppendLine("#endif");
        _sb.AppendLine("        return result;");
        _sb.AppendLine("    }");
        _sb.AppendLine();
        
        _sb.AppendLine($"    /// <summary>Safe collection mapper for {mapping.SourceTypeName} to {mapping.DestinationTypeName} array (value types).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static {mapping.DestinationType}[] MapArray(");
        _sb.AppendLine($"        {mapping.SourceType}[]? source,");
        _sb.AppendLine($"        Func<{mapping.SourceType}, {mapping.DestinationType}> mapper)");
        _sb.AppendLine("    {");
        _sb.AppendLine("        if (source is null || source.Length == 0)");
        _sb.AppendLine("            return Array.Empty<" + mapping.DestinationType + ">();");
        _sb.AppendLine();
        _sb.AppendLine("        var result = new " + mapping.DestinationType + "[source.Length];");
        _sb.AppendLine("        for (int i = 0; i < source.Length; i++)");
        _sb.AppendLine("            result[i] = mapper(source[i]);");
        _sb.AppendLine("        return result;");
        _sb.AppendLine("    }");
    }

    private void AppendToSpanMethod(MappingConfiguration mapping)
    {
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>Maps ReadOnlySpan of {mapping.SourceTypeName} to Span of {mapping.DestinationTypeName} (true zero-allocation, ref-optimized).</summary>");
        _sb.AppendLine("    /// <remarks>");
        _sb.AppendLine("    /// ⚠️ WARNING: Destination span must have EXACTLY source.Length capacity!");
        _sb.AppendLine("    /// Stack-allocated spans (stackalloc T[100]) may overflow if used with large source spans.");
        _sb.AppendLine("    /// For untrusted input sizes, use ToList() or ToArray() instead.");
        _sb.AppendLine("    /// </remarks>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static void ToSpan(ReadOnlySpan<{mapping.SourceType}> source, Span<{mapping.DestinationType}> destination)");
        _sb.AppendLine("    {");
        _sb.AppendLine("        if ((uint)source.Length > (uint)destination.Length)");
        _sb.AppendLine("            throw new ArgumentException(\"Destination span must be at least as long as source span.\", nameof(destination));");
        _sb.AppendLine();
        _sb.AppendLine("        // Ref-based loop for zero bounds-checking");
        _sb.AppendLine("        ref var srcRef = ref System.Runtime.InteropServices.MemoryMarshal.GetReference(source);");
        _sb.AppendLine("        ref var dstRef = ref System.Runtime.InteropServices.MemoryMarshal.GetReference(destination);");
        _sb.AppendLine("        nuint length = (nuint)source.Length;");
        _sb.AppendLine("        for (nuint i = 0; i < length; i++)");
        _sb.AppendLine($"            System.Runtime.CompilerServices.Unsafe.Add(ref dstRef, i) = To(System.Runtime.CompilerServices.Unsafe.Add(ref srcRef, i));");
        _sb.AppendLine("    }");
    }

    private void AppendToListMethod(MappingConfiguration mapping)
    {
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>Maps IEnumerable of {mapping.SourceTypeName} to List of {mapping.DestinationTypeName} (zero-boxing, ref-optimized).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static List<{mapping.DestinationType}> ToList(IEnumerable<{mapping.SourceType}>? source)");
        _sb.AppendLine("    {");
        _sb.AppendLine($"        if (source is null) return new List<{mapping.DestinationType}>();");
        _sb.AppendLine();

        // Fast path for List<T> with ref-based loop and unrolling
        _sb.AppendLine($"        if (source is List<{mapping.SourceType}> sourceList)");
        _sb.AppendLine("        {");
        _sb.AppendLine($"            if (sourceList.Count == 0) return new List<{mapping.DestinationType}>();");
        _sb.AppendLine("            var count = sourceList.Count;");
        _sb.AppendLine($"            var result = new List<{mapping.DestinationType}>(count);");
        _sb.AppendLine("#if NET8_0_OR_GREATER");
        _sb.AppendLine("            CollectionsMarshal.SetCount(result, count);");
        _sb.AppendLine("            ref var sourceRef = ref System.Runtime.InteropServices.MemoryMarshal.GetReference(CollectionsMarshal.AsSpan(sourceList));");
        _sb.AppendLine("            ref var destRef = ref System.Runtime.InteropServices.MemoryMarshal.GetReference(CollectionsMarshal.AsSpan(result));");
        _sb.AppendLine("            ");
        _sb.AppendLine("            nuint i = 0;");
        _sb.AppendLine("            nuint length = (nuint)count;");
        _sb.AppendLine("            ");
        _sb.AppendLine("            // 8-way unrolled loop for maximum throughput");
        _sb.AppendLine("            while (i + 8 <= length)");
        _sb.AppendLine("            {");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref destRef, i) = To(System.Runtime.CompilerServices.Unsafe.Add(ref sourceRef, i));");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref destRef, i + 1) = To(System.Runtime.CompilerServices.Unsafe.Add(ref sourceRef, i + 1));");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref destRef, i + 2) = To(System.Runtime.CompilerServices.Unsafe.Add(ref sourceRef, i + 2));");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref destRef, i + 3) = To(System.Runtime.CompilerServices.Unsafe.Add(ref sourceRef, i + 3));");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref destRef, i + 4) = To(System.Runtime.CompilerServices.Unsafe.Add(ref sourceRef, i + 4));");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref destRef, i + 5) = To(System.Runtime.CompilerServices.Unsafe.Add(ref sourceRef, i + 5));");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref destRef, i + 6) = To(System.Runtime.CompilerServices.Unsafe.Add(ref sourceRef, i + 6));");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref destRef, i + 7) = To(System.Runtime.CompilerServices.Unsafe.Add(ref sourceRef, i + 7));");
        _sb.AppendLine("                i += 8;");
        _sb.AppendLine("            }");
        _sb.AppendLine("            ");
        _sb.AppendLine("            // Handle remaining items");
        _sb.AppendLine("            while (i < length)");
        _sb.AppendLine("            {");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref destRef, i) = To(System.Runtime.CompilerServices.Unsafe.Add(ref sourceRef, i));");
        _sb.AppendLine("                i++;");
        _sb.AppendLine("            }");
        _sb.AppendLine("#else");
        _sb.AppendLine("            foreach (var item in sourceList)");
        _sb.AppendLine($"                result.Add(To(item));");
        _sb.AppendLine("#endif");
        _sb.AppendLine("            return result;");
        _sb.AppendLine("        }");
        _sb.AppendLine();

        // Fast path for arrays with ref-based loop
        _sb.AppendLine($"        if (source is {mapping.SourceType}[] sourceArray)");
        _sb.AppendLine("        {");
        _sb.AppendLine($"            if (sourceArray.Length == 0) return new List<{mapping.DestinationType}>();");
        _sb.AppendLine("            var count = sourceArray.Length;");
        _sb.AppendLine($"            var result = new List<{mapping.DestinationType}>(count);");
        _sb.AppendLine("#if NET8_0_OR_GREATER");
        _sb.AppendLine("            CollectionsMarshal.SetCount(result, count);");
        _sb.AppendLine("            ref var arrRef = ref System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference(sourceArray);");
        _sb.AppendLine("            ref var destRef = ref System.Runtime.InteropServices.MemoryMarshal.GetReference(CollectionsMarshal.AsSpan(result));");
        _sb.AppendLine("            for (nuint i = 0; i < (nuint)count; i++)");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref destRef, i) = To(System.Runtime.CompilerServices.Unsafe.Add(ref arrRef, i));");
        _sb.AppendLine("#else");
        _sb.AppendLine("            foreach (var item in sourceArray)");
        _sb.AppendLine($"                result.Add(To(item));");
        _sb.AppendLine("#endif");
        _sb.AppendLine("            return result;");
        _sb.AppendLine("        }");
        _sb.AppendLine();

        // ICollection fast-path
        _sb.AppendLine($"        if (source is ICollection<{mapping.SourceType}> collection)");
        _sb.AppendLine("        {");
        _sb.AppendLine("            var count = collection.Count;");
        _sb.AppendLine($"            if (count == 0) return new List<{mapping.DestinationType}>();");
        _sb.AppendLine($"            var result = new List<{mapping.DestinationType}>(count);");
        _sb.AppendLine("            foreach (var item in collection)");
        _sb.AppendLine($"                result.Add(To(item));");
        _sb.AppendLine("            return result;");
        _sb.AppendLine("        }");
        _sb.AppendLine();

        // Slow path for unknown IEnumerable
        _sb.AppendLine($"        var list = new List<{mapping.DestinationType}>();");
        _sb.AppendLine("        foreach (var item in source)");
        _sb.AppendLine($"            list.Add(To(item));");
        _sb.AppendLine("        return list;");
        _sb.AppendLine("    }");
        _sb.AppendLine();
        
        // Generic overload for backward compatibility
        _sb.AppendLine($"    /// <summary>Maps IEnumerable of {mapping.SourceTypeName} to List of TDestination (generic overload for compatibility).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"    public static List<TDestination> ToList<TDestination>(IEnumerable<{mapping.SourceType}>? source) where TDestination : {mapping.DestinationType}");
        _sb.AppendLine("    {");
        _sb.AppendLine("        return ToList(source).ConvertAll(item => (TDestination)(object)item!);");
        _sb.AppendLine("    }");
    }

    private void AppendToArrayMethod(MappingConfiguration mapping)
    {
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>Maps IEnumerable of {mapping.SourceTypeName} to array of {mapping.DestinationTypeName} (zero-boxing, ref-optimized).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static {mapping.DestinationType}[] ToArray(IEnumerable<{mapping.SourceType}>? source)");
        _sb.AppendLine("    {");
        _sb.AppendLine($"        if (source is null) return Array.Empty<{mapping.DestinationType}>();");
        _sb.AppendLine();

        // Fast path for arrays with ref-based loop
        _sb.AppendLine($"        if (source is {mapping.SourceType}[] sourceArray)");
        _sb.AppendLine("        {");
        _sb.AppendLine($"            if (sourceArray.Length == 0) return Array.Empty<{mapping.DestinationType}>();");
        _sb.AppendLine($"            var result = new {mapping.DestinationType}[sourceArray.Length];");
        _sb.AppendLine("#if NET6_0_OR_GREATER");
        _sb.AppendLine("            ref var srcRef = ref System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference(sourceArray);");
        _sb.AppendLine("            ref var dstRef = ref System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference(result);");
        _sb.AppendLine("            nuint length = (nuint)sourceArray.Length;");
        _sb.AppendLine("            for (nuint i = 0; i < length; i++)");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref dstRef, i) = To(System.Runtime.CompilerServices.Unsafe.Add(ref srcRef, i));");
        _sb.AppendLine("#else");
        _sb.AppendLine("            for (int i = 0; i < sourceArray.Length; i++)");
        _sb.AppendLine($"                result[i] = To(sourceArray[i]);");
        _sb.AppendLine("#endif");
        _sb.AppendLine("            return result;");
        _sb.AppendLine("        }");
        _sb.AppendLine();

        // Fast path for List<T>
        _sb.AppendLine($"        if (source is List<{mapping.SourceType}> list)");
        _sb.AppendLine("        {");
        _sb.AppendLine($"            if (list.Count == 0) return Array.Empty<{mapping.DestinationType}>();");
        _sb.AppendLine($"            var result = new {mapping.DestinationType}[list.Count];");
        _sb.AppendLine("#if NET6_0_OR_GREATER");
        _sb.AppendLine("            var sourceSpan = CollectionsMarshal.AsSpan(list);");
        _sb.AppendLine("            ref var srcRef = ref System.Runtime.InteropServices.MemoryMarshal.GetReference(sourceSpan);");
        _sb.AppendLine("            ref var dstRef = ref System.Runtime.InteropServices.MemoryMarshal.GetArrayDataReference(result);");
        _sb.AppendLine("            nuint length = (nuint)list.Count;");
        _sb.AppendLine("            for (nuint i = 0; i < length; i++)");
        _sb.AppendLine($"                System.Runtime.CompilerServices.Unsafe.Add(ref dstRef, i) = To(System.Runtime.CompilerServices.Unsafe.Add(ref srcRef, i));");
        _sb.AppendLine("#else");
        _sb.AppendLine("            for (int i = 0; i < list.Count; i++)");
        _sb.AppendLine($"                result[i] = To(list[i]);");
        _sb.AppendLine("#endif");
        _sb.AppendLine("            return result;");
        _sb.AppendLine("        }");
        _sb.AppendLine();

        // Fallback to list then array
        _sb.AppendLine("        return ToList(source).ToArray();");
        _sb.AppendLine("    }");
        _sb.AppendLine();
        
        // Generic overload for backward compatibility
        _sb.AppendLine($"    /// <summary>Maps IEnumerable of {mapping.SourceTypeName} to array of TDestination (generic overload for compatibility).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"    public static TDestination[] ToArray<TDestination>(IEnumerable<{mapping.SourceType}>? source) where TDestination : {mapping.DestinationType}");
        _sb.AppendLine("    {");
        _sb.AppendLine("        var array = ToArray(source);");
        _sb.AppendLine("        if (typeof(TDestination) == typeof(" + mapping.DestinationType + "))");
        _sb.AppendLine("            return (TDestination[])(object)array;");
        _sb.AppendLine("        var result = new TDestination[array.Length];");
        _sb.AppendLine("        for (int i = 0; i < array.Length; i++)");
        _sb.AppendLine("            result[i] = (TDestination)(object)array[i]!;");
        _sb.AppendLine("        return result;");
        _sb.AppendLine("    }");
    }

    private void AppendToEnumerableMethod(MappingConfiguration mapping)
    {
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>Maps IEnumerable of {mapping.SourceTypeName} to IEnumerable of {mapping.DestinationTypeName} (lazy evaluation, zero-boxing).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"    public static IEnumerable<{mapping.DestinationType}> ToEnumerable(IEnumerable<{mapping.SourceType}>? source)");
        _sb.AppendLine("    {");
        _sb.AppendLine("        if (source is null) yield break;");
        _sb.AppendLine("        foreach (var item in source)");
        _sb.AppendLine($"            yield return To(item);");
        _sb.AppendLine("    }");
        _sb.AppendLine();
        
        // Generic overload for backward compatibility
        _sb.AppendLine($"    /// <summary>Maps IEnumerable of {mapping.SourceTypeName} to IEnumerable of TDestination (generic overload for compatibility).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"    public static IEnumerable<TDestination> ToEnumerable<TDestination>(IEnumerable<{mapping.SourceType}>? source) where TDestination : {mapping.DestinationType}");
        _sb.AppendLine("    {");
        _sb.AppendLine("        if (source is null) yield break;");
        _sb.AppendLine("        foreach (var item in ToEnumerable(source))");
        _sb.AppendLine("            yield return (TDestination)(object)item!;");
        _sb.AppendLine("    }");
    }

    private void AppendToCollectionMethod(MappingConfiguration mapping)
    {
        _sb.AppendLine();
        _sb.AppendLine($"    /// <summary>Maps IEnumerable of {mapping.SourceTypeName} to Collection of {mapping.DestinationTypeName} (zero-boxing).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]");
        _sb.AppendLine($"    public static Collection<{mapping.DestinationType}> ToCollection(IEnumerable<{mapping.SourceType}>? source)");
        _sb.AppendLine("    {");
        _sb.AppendLine($"        if (source is null) return new Collection<{mapping.DestinationType}>();");
        _sb.AppendLine("        var list = ToList(source);");
        _sb.AppendLine($"        return new Collection<{mapping.DestinationType}>(list);");
        _sb.AppendLine("    }");
        _sb.AppendLine();
        
        // Generic overload for backward compatibility
        _sb.AppendLine($"    /// <summary>Maps IEnumerable of {mapping.SourceTypeName} to Collection of TDestination (generic overload for compatibility).</summary>");
        _sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        _sb.AppendLine($"    public static Collection<TDestination> ToCollection<TDestination>(IEnumerable<{mapping.SourceType}>? source) where TDestination : {mapping.DestinationType}");
        _sb.AppendLine("    {");
        _sb.AppendLine("        var list = ToList<TDestination>(source);");
        _sb.AppendLine("        return new Collection<TDestination>(list);");
        _sb.AppendLine("    }");
    }

    /// <summary>
    /// Gets or analyzes a mapping plan, using cache to avoid redundant symbol walking.
    /// </summary>
    private PropertyMappingPlan GetOrAnalyzeMappingPlan(
        MappingConfiguration config,
        IReadOnlyList<PropertyInfo> destProperties,
        IReadOnlyList<PropertyInfo> sourceProperties,
        IReadOnlyList<MappingConfiguration> allMappings)
    {
        var cacheKey = $"{config.SourceTypeFullName}|{config.DestinationTypeFullName}";
        
        if (!_mappingPlanCache.TryGetValue(cacheKey, out var plan))
        {
            var analyzer = new PropertyMappingAnalyzer(allMappings);
            plan = analyzer.AnalyzeMappings(config, destProperties, sourceProperties);
            _mappingPlanCache[cacheKey] = plan;
        }
        
        return plan;
    }

    /// <summary>
    /// Gets or caches public properties for a type symbol.
    /// </summary>
    private IReadOnlyList<PropertyInfo> GetOrCacheProperties(ITypeSymbol typeSymbol)
    {
        if (!_propertyCache.TryGetValue(typeSymbol, out var properties))
        {
            properties = SymbolAnalysisHelper.GetPublicProperties(typeSymbol);
            _propertyCache[typeSymbol] = properties;
        }
        
        return properties;
    }
}
