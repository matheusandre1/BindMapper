using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Collections.ObjectModel;

namespace BindMapper;

public static partial class Mapper
{
    /// <summary>
    /// Maps source to a new TDestination instance.
    /// This method is generated by the Source Generator based on your [MapperConfiguration] definitions.
    /// </summary>
    /// <typeparam name="TDestination">The destination type to create and map to.</typeparam>
    /// <param name="source">The source object to map from. Cannot be null.</param>
    /// <returns>A new instance of TDestination with properties mapped from source.</returns>
    /// <exception cref="InvalidOperationException">Thrown if no mapping is configured for this type pair.</exception>
    /// <remarks>
    /// Performance: ~12 ns (benchmark on .NET 10, Intel Core i5-14600KF)
    /// The generated code is fully inlinable and optimized for JIT.
    /// </remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static TDestination To<TDestination>(object source)
    {
        ThrowNoMappingConfigured(source?.GetType(), typeof(TDestination));
        return default!;
    }

    /// <summary>
    /// Maps source to an existing TDestination instance, modifying it in-place.
    /// This method is generated by the Source Generator based on your [MapperConfiguration] definitions.
    /// </summary>
    /// <typeparam name="TDestination">The destination type (must be a class).</typeparam>
    /// <param name="source">The source object to map from.</param>
    /// <param name="destination">The existing destination instance to update. Cannot be null.</param>
    /// <exception cref="InvalidOperationException">Thrown if no mapping is configured for this type pair.</exception>
    /// <remarks>
    /// Performance: ~10 ns, ZERO allocation (benchmark on .NET 10)
    /// Ideal for reusing objects and avoiding GC pressure.
    /// This is the fastest mapping method as it doesn't allocate new memory.
    /// </remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void To<TDestination>(object source, TDestination destination) where TDestination : class
    {
        _ = destination;
        ThrowNoMappingConfigured(source?.GetType(), typeof(TDestination));
    }

    [MethodImpl(MethodImplOptions.NoInlining)]
    private static void ThrowNoMappingConfigured(Type? sourceType, Type destinationType)
    {
        var guidance = $"Expected to find a [MapperConfiguration] method like: " +
            $"[MapperConfiguration] public static void Configure() {{ " +
            $"MapperSetup.CreateMap<{sourceType?.Name}, {destinationType.Name}>(); }} " +
            $"If this mapping is in another assembly, ensure [MapperConfiguration] is called before using Mapper.To<T>().";
        
        throw new InvalidOperationException(
            $"No mapping configured from '{sourceType?.FullName ?? "null"}' to '{destinationType.FullName}'. {guidance}");
    }

    #region Collection Mapping

    /// <summary>
    /// Maps a list to another list using a provided mapping function.
    /// Optimized for performance using Span&lt;T&gt; and CollectionsMarshal on .NET 8+.
    /// </summary>
    /// <typeparam name="TSource">The source item type.</typeparam>
    /// <typeparam name="TDestination">The destination item type.</typeparam>
    /// <param name="source">The source list to map from. Can be null or empty.</param>
    /// <param name="mapper">The function that maps each source item to destination. Cannot be null.</param>
    /// <returns>A new list containing mapped items. Empty list if source is null or empty.</returns>
    /// <remarks>
    /// <para>Performance optimizations:</para>
    /// <list type="bullet">
    ///     <item>.NET 8+: Uses CollectionsMarshal.AsSpan() for zero-allocation enumeration</item>
    ///     <item>.NET 6-7: Uses standard foreach loop</item>
    /// </list>
    /// <para>Example:</para>
    /// <code>
    /// var users = GetUsers();
    /// var dtos = Mapper.MapList(users, u => Mapper.To&lt;UserDto&gt;(u));
    /// </code>
    /// </remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static List<TDestination> MapList<TSource, TDestination>(
        List<TSource>? source,
        Func<TSource, TDestination> mapper)
    {
        if (source is null || source.Count == 0)
            return new List<TDestination>();

        var count = source.Count;
        var destination = new List<TDestination>(count);

#if NET8_0_OR_GREATER
        // Use CollectionsMarshal for zero-allocation enumeration
        var sourceSpan = CollectionsMarshal.AsSpan(source);
        
        // Pre-allocate capacity
        CollectionsMarshal.SetCount(destination, count);
        var destSpan = CollectionsMarshal.AsSpan(destination);

        // Map using spans for better performance
        for (int i = 0; i < sourceSpan.Length; i++)
        {
            destSpan[i] = mapper(sourceSpan[i]);
        }
#else
        // Fallback for older frameworks - still optimized
        foreach (var item in source)
        {
            destination.Add(mapper(item));
        }
#endif

        return destination;
    }

    /// <summary>
    /// Maps an array to another array using a provided mapping function.
    /// Optimized for performance using Span&lt;T&gt; internally.
    /// </summary>
    /// <typeparam name="TSource">The source item type.</typeparam>
    /// <typeparam name="TDestination">The destination item type.</typeparam>
    /// <param name="source">The source array to map from. Can be null or empty.</param>
    /// <param name="mapper">The function that maps each source item to destination. Cannot be null.</param>
    /// <returns>A new array containing mapped items. Empty array if source is null or empty.</returns>
    /// <remarks>
    /// Uses Span&lt;T&gt; internally for zero-copy iteration over array memory.
    /// This is the fastest collection mapping method for arrays.
    /// </remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static TDestination[] MapArray<TSource, TDestination>(
        TSource[]? source,
        Func<TSource, TDestination> mapper)
    {
        if (source is null || source.Length == 0)
            return Array.Empty<TDestination>();

        var length = source.Length;
        var destination = new TDestination[length];
        var sourceSpan = source.AsSpan();
        var destSpan = destination.AsSpan();

        // Use span-based iteration for better performance
        for (int i = 0; i < length; i++)
        {
            destSpan[i] = mapper(sourceSpan[i]);
        }

        return destination;
    }

    /// <summary>
    /// Maps an enumerable to a list using a provided mapping function.
    /// Automatically detects source type (List, Array, ICollection) and chooses the fastest path.
    /// </summary>
    /// <typeparam name="TSource">The source item type.</typeparam>
    /// <typeparam name="TDestination">The destination item type.</typeparam>
    /// <param name="source">The source enumerable to map from. Can be null.</param>
    /// <param name="mapper">The function that maps each source item to destination. Cannot be null.</param>
    /// <returns>A new list containing mapped items. Empty list if source is null or empty.</returns>
    /// <remarks>
    /// <para>Auto-detection optimization:</para>
    /// <list type="bullet">
    ///     <item>List&lt;T&gt;: Fast-path with Span optimization</item>
    ///     <item>T[]: Fast-path with Span zero-copy</item>
    ///     <item>ICollection&lt;T&gt;: Fast-path with count pre-allocation</item>
    ///     <item>IEnumerable&lt;T&gt;: Generic path with natural growth</item>
    /// </list>
    /// <para>This method always returns a materialized List (not lazy).</para>
    /// </remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static List<TDestination> MapEnumerable<TSource, TDestination>(
        IEnumerable<TSource>? source,
        Func<TSource, TDestination> mapper)
    {
        if (source is null)
            return new List<TDestination>();

        // Fast path for List<T>
        if (source is List<TSource> list)
            return MapList(list, mapper);

        // Fast path for arrays
        if (source is TSource[] array)
        {
            if (array.Length == 0)
                return new List<TDestination>();

            var arrayDestination = new List<TDestination>(array.Length);

#if NET8_0_OR_GREATER
            CollectionsMarshal.SetCount(arrayDestination, array.Length);
            var destSpan = CollectionsMarshal.AsSpan(arrayDestination);
            var sourceSpan = array.AsSpan();

            for (int i = 0; i < sourceSpan.Length; i++)
            {
                destSpan[i] = mapper(sourceSpan[i]);
            }
#else
            for (int i = 0; i < array.Length; i++)
            {
                arrayDestination.Add(mapper(array[i]));
            }
#endif

            return arrayDestination;
        }

        // Fast path for ICollection<T>
        if (source is ICollection<TSource> collection)
            return MapToList(collection, mapper);

#if NET6_0_OR_GREATER
        // Try to get count without enumeration for pre-allocation
        if (System.Linq.Enumerable.TryGetNonEnumeratedCount(source, out var estimatedCount))
        {
            var destination = new List<TDestination>(estimatedCount);
            foreach (var item in source)
            {
                destination.Add(mapper(item));
            }
            return destination;
        }
#endif

        // Slow path for IEnumerable - let List grow naturally, no hardcoded capacity
        var result = new List<TDestination>();

        foreach (var item in source)
        {
            result.Add(mapper(item));
        }

        return result;
    }

    /// <summary>
    /// Maps a read-only span to an array using a mapping function.
    /// Maximum performance for span-based operations — TRUE zero allocation.
    /// </summary>
    /// <typeparam name="TSource">The source item type.</typeparam>
    /// <typeparam name="TDestination">The destination item type.</typeparam>
    /// <param name="source">The source span to map from.</param>
    /// <param name="mapper">The function that maps each source item to destination. Cannot be null.</param>
    /// <returns>A new array containing mapped items. Empty array if source is empty.</returns>
    /// <remarks>
    /// <para>⚠️ WARNING: This method ALLOCATES a heap array for the result.</para>
    /// <para>If you need TRUE zero-allocation mapping, pre-allocate a destination Span and use manual iteration:</para>
    /// <code>
    /// Span&lt;UserDto&gt; dest = stackalloc UserDto[users.Length];
    /// for (int i = 0; i &lt; users.Length; i++)
    /// {
    ///     dest[i] = Mapper.To&lt;UserDto&gt;(users[i]);
    /// }
    /// </code>
    /// <para>This method is useful when you need an array result from span input.</para>
    /// </remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static TDestination[] MapSpan<TSource, TDestination>(
        ReadOnlySpan<TSource> source,
        Func<TSource, TDestination> mapper)
    {
        if (source.IsEmpty)
            return Array.Empty<TDestination>();

        var destination = new TDestination[source.Length];
        var destSpan = destination.AsSpan();

        for (int i = 0; i < source.Length; i++)
        {
            destSpan[i] = mapper(source[i]);
        }

        return destination;
    }

    /// <summary>
    /// Maps a collection to a list using a provided mapping function.
    /// Optimized for ICollection&lt;T&gt; to avoid enumerator overhead.
    /// LEGACY API: Prefer MapList(List&lt;T&gt;, ...) or MapEnumerable(IEnumerable&lt;T&gt;, ...) for new code.
    /// </summary>
    /// <typeparam name="TSource">The source item type.</typeparam>
    /// <typeparam name="TDestination">The destination item type.</typeparam>
    /// <param name="source">The source collection to map from. Cannot be null.</param>
    /// <param name="mapper">The function that maps each source item to destination. Cannot be null.</param>
    /// <returns>A new list containing mapped items.</returns>
    /// <remarks>
    /// This method is still optimized but kept for backward compatibility.
    /// Use MapEnumerable for better auto-detection of input types.
    /// </remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static List<TDestination> MapToList<TSource, TDestination>(
        ICollection<TSource> source,
        Func<TSource, TDestination> mapper)
    {
        if (source.Count == 0)
            return new List<TDestination>();

        var destination = new List<TDestination>(source.Count);

#if NET8_0_OR_GREATER
        CollectionsMarshal.SetCount(destination, source.Count);
        var destSpan = CollectionsMarshal.AsSpan(destination);
        var i = 0;
        foreach (var item in source)
        {
            destSpan[i++] = mapper(item);
        }
#else
        foreach (var item in source)
        {
            destination.Add(mapper(item));
        }
#endif

        return destination;
    }

    /// <summary>
    /// Maps a collection to an array using a provided mapping function.
    /// Optimized for ICollection&lt;T&gt; to avoid intermediate lists.
    /// LEGACY API: Prefer MapArray(T[], ...) or MapEnumerable(IEnumerable&lt;T&gt;, ...) for new code.
    /// </summary>
    /// <typeparam name="TSource">The source item type.</typeparam>
    /// <typeparam name="TDestination">The destination item type.</typeparam>
    /// <param name="source">The source collection to map from. Cannot be null.</param>
    /// <param name="mapper">The function that maps each source item to destination. Cannot be null.</param>
    /// <returns>A new array containing mapped items.</returns>
    /// <remarks>
    /// This method is still optimized but kept for backward compatibility.
    /// Use MapEnumerable for better auto-detection of input types.
    /// </remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static TDestination[] MapToArray<TSource, TDestination>(
        ICollection<TSource> source,
        Func<TSource, TDestination> mapper)
    {
        if (source.Count == 0)
            return Array.Empty<TDestination>();

        var destination = new TDestination[source.Count];
        var i = 0;
        foreach (var item in source)
        {
            destination[i++] = mapper(item);
        }

        return destination;
    }

    /// <summary>
    /// Maps a collection to a Collection&lt;TDestination&gt; using a provided mapping function.
    /// Optimized for ICollection&lt;T&gt; to avoid enumerator overhead.
    /// </summary>
    /// <typeparam name="TSource">The source item type.</typeparam>
    /// <typeparam name="TDestination">The destination item type.</typeparam>
    /// <param name="source">The source collection to map from. Cannot be null.</param>
    /// <param name="mapper">The function that maps each source item to destination. Cannot be null.</param>
    /// <returns>A new Collection&lt;TDestination&gt; containing mapped items.</returns>
    /// <remarks>
    /// This method creates a Collection&lt;T&gt; which is useful for data binding scenarios
    /// and when you need a concrete collection type with observable capabilities.
    /// </remarks>
    [MethodImpl(MethodImplOptions.AggressiveInlining | MethodImplOptions.AggressiveOptimization)]
    public static Collection<TDestination> ToCollection<TSource, TDestination>(
        ICollection<TSource> source,
        Func<TSource, TDestination> mapper)
    {
        if (source.Count == 0)
            return new Collection<TDestination>();

        var list = new List<TDestination>(source.Count);

#if NET8_0_OR_GREATER
        CollectionsMarshal.SetCount(list, source.Count);
        var destSpan = CollectionsMarshal.AsSpan(list);
        var i = 0;
        foreach (var item in source)
        {
            destSpan[i++] = mapper(item);
        }
#else
        foreach (var item in source)
        {
            list.Add(mapper(item));
        }
#endif

        return new Collection<TDestination>(list);
    }

    #endregion
}
